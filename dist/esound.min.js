/******/ var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Tween": () => (/* binding */ r)
/* harmony export */ });
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
/**
* Class for creating a tweening animation
* @class Tween  
* @license
* Tween does not have a license at this time.
* For licensing contact the author
* @author https://github.com/doubleactii
* Copyright (c) 2023 Evitca Studio
*/
var r = /*#__PURE__*/function () {
  function r() {
    var _this = this;
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$start = _ref.start,
      _t = _ref$start === void 0 ? {} : _ref$start,
      _ref$end = _ref.end,
      _e = _ref$end === void 0 ? {} : _ref$end,
      _ref$duration = _ref.duration,
      _s = _ref$duration === void 0 ? 1e3 : _ref$duration,
      _ref$easing = _ref.easing,
      _a = _ref$easing === void 0 ? r.linear : _ref$easing;
    _classCallCheck(this, r);
    _defineProperty(this, "animationFrame", function () {
      if (_this.tweening && !_this.paused) {
        var t = performance.now();
        _this.lastTime || (_this.lastTime = t), _this.elapsed += t - _this.lastTime;
        var s = _this.elapsed / _this.duration;
        1 < (s = _this.oscillating ? (1 - Math.cos(s * Math.PI)) / 2 : s) && (s = 1);
        var a,
          i,
          n = {};
        for (a in _this.end) {
          var _t2 = _this.start[a],
            e = _this.end[a];
          "string" == typeof _t2 && (3 === _t2.length || 6 === _t2.length) || 4 === _t2.length || 7 === _t2.length ? (_t2 = r._hexToRgb(_t2), e = r._hexToRgb(e), i = [_this.easing(s, _t2[0], e[0] - _t2[0], 1), _this.easing(s, _t2[1], e[1] - _t2[1], 1), _this.easing(s, _t2[2], e[2] - _t2[2], 1)], n[a] = r._rgbToHex(i)) : n[a] = _this.easing(s, _t2, e - _t2, 1);
        }
        _this.update(n), 1 !== s || _this.oscillating ? requestAnimationFrame(_this.animationFrame) : (_this.stop(), _this.events.end && _this.events.end()), _this.lastTime = t;
      }
    });
    this._build(_t, _e, _s, _a);
  }
  _createClass(r, [{
    key: "_build",
    value: function _build(t, e, s, a) {
      this.start = t, this.end = e, this.duration = s, this.easing = "function" == typeof a ? a : r.linear, this.events = {}, this.tweening = !1, this.update = null, this.paused = !1, this.lastTime = 0, this.elapsed = 0;
    }
  }, {
    key: "build",
    value: function build() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref2$start = _ref2.start,
        t = _ref2$start === void 0 ? {} : _ref2$start,
        _ref2$end = _ref2.end,
        e = _ref2$end === void 0 ? {} : _ref2$end,
        _ref2$duration = _ref2.duration,
        s = _ref2$duration === void 0 ? 1e3 : _ref2$duration,
        _ref2$easing = _ref2.easing,
        a = _ref2$easing === void 0 ? r.linear : _ref2$easing;
      return this._build(t, e, s, a), this;
    }
  }, {
    key: "on",
    value: function on(t, e) {
      if ("function" == typeof e) switch (t) {
        case "start":
        case "end":
        case "pause":
        case "resume":
          this.events[t] = e;
          break;
        default:
          console.error("The event \"".concat(t, "\" is not supported."));
      } else console.error("The callback for event \"".concat(t, "\" is not a function."));
      return this;
    }
  }, {
    key: "animate",
    value: function animate(t) {
      var s = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
      if ("function" != typeof t) console.error("The pUpdate parameter passed to animate is not a function.");else if (!this.tweening) {
        var a = Object.keys(this.start);
        var e = Object.keys(this.end);
        if (a.length && e.length) {
          if (a.every(function (t) {
            return e.includes(t);
          })) return this.update = t, this.tweening = !0, this.elapsed = 0, this.oscillating = s, this.events.start && this.events.start(), requestAnimationFrame(this.animationFrame), this;
          console.error("The end object is missing properties that the start object has.");
        } else console.error("The start object or the end object has no properties.");
      }
    }
  }, {
    key: "resume",
    value: function resume() {
      return this.paused && (this.lastTime = performance.now(), this.paused = !1, this.events.resume && this.events.resume(), requestAnimationFrame(this.animationFrame)), this;
    }
  }, {
    key: "pause",
    value: function pause() {
      return this.paused || (this.paused = !0, this.events.pause && this.events.pause()), this;
    }
  }, {
    key: "stop",
    value: function stop() {
      this.tweening = !1, this.oscillating = !1, this.update = null, this.elapsed = 0, this.lastTime = 0, this.paused = !1;
    }
  }], [{
    key: "linear",
    value: function linear(t, e, s, a) {
      return s * t / a + e;
    }
  }, {
    key: "easeInQuad",
    value: function easeInQuad(t, e, s, a) {
      return s * (t /= a) * t + e;
    }
  }, {
    key: "easeOutQuad",
    value: function easeOutQuad(t, e, s, a) {
      return -s * (t /= a) * (t - 2) + e;
    }
  }, {
    key: "easeInOutQuad",
    value: function easeInOutQuad(t, e, s, a) {
      return (t /= a / 2) < 1 ? s / 2 * t * t + e : -s / 2 * (--t * (t - 2) - 1) + e;
    }
  }, {
    key: "easeInSine",
    value: function easeInSine(t, e, s, a) {
      return -s * Math.cos(t / a * (Math.PI / 2)) + s + e;
    }
  }, {
    key: "easeOutSine",
    value: function easeOutSine(t, e, s, a) {
      return s * Math.sin(t / a * (Math.PI / 2)) + e;
    }
  }, {
    key: "easeInOutSine",
    value: function easeInOutSine(t, e, s, a) {
      return -s / 2 * (Math.cos(Math.PI * t / a) - 1) + e;
    }
  }, {
    key: "easeInExpo",
    value: function easeInExpo(t, e, s, a) {
      return 0 == t ? e : s * Math.pow(2, 10 * (t / a - 1)) + e;
    }
  }, {
    key: "easeOutExpo",
    value: function easeOutExpo(t, e, s, a) {
      return t == a ? e + s : s * (1 - Math.pow(2, -10 * t / a)) + e;
    }
  }, {
    key: "easeInOutExpo",
    value: function easeInOutExpo(t, e, s, a) {
      return 0 == t ? e : t == a ? e + s : (t /= a / 2) < 1 ? s / 2 * Math.pow(2, 10 * (t - 1)) + e : s / 2 * (2 - Math.pow(2, -10 * --t)) + e;
    }
  }, {
    key: "easeInCirc",
    value: function easeInCirc(t, e, s, a) {
      return -s * (Math.sqrt(1 - (t /= a) * t) - 1) + e;
    }
  }, {
    key: "easeOutCirc",
    value: function easeOutCirc(t, e, s, a) {
      return s * Math.sqrt(1 - (t = t / a - 1) * t) + e;
    }
  }, {
    key: "easeInOutCirc",
    value: function easeInOutCirc(t, e, s, a) {
      return (t /= a / 2) < 1 ? -s / 2 * (Math.sqrt(1 - t * t) - 1) + e : s / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + e;
    }
  }, {
    key: "easeInCubic",
    value: function easeInCubic(t, e, s, a) {
      return s * (t /= a) * t * t + e;
    }
  }, {
    key: "easeOutCubic",
    value: function easeOutCubic(t, e, s, a) {
      return s * ((t = t / a - 1) * t * t + 1) + e;
    }
  }, {
    key: "easeInOutCubic",
    value: function easeInOutCubic(t, e, s, a) {
      return (t /= a / 2) < 1 ? s / 2 * t * t * t + e : s / 2 * ((t -= 2) * t * t + 2) + e;
    }
  }, {
    key: "easeInQuart",
    value: function easeInQuart(t, e, s, a) {
      return s * (t /= a) * t * t * t + e;
    }
  }, {
    key: "easeOutQuart",
    value: function easeOutQuart(t, e, s, a) {
      return -s * ((t = t / a - 1) * t * t * t - 1) + e;
    }
  }, {
    key: "easeInOutQuart",
    value: function easeInOutQuart(t, e, s, a) {
      return (t /= a / 2) < 1 ? s / 2 * t * t * t * t + e : -s / 2 * ((t -= 2) * t * t * t - 2) + e;
    }
  }, {
    key: "easeInQuint",
    value: function easeInQuint(t, e, s, a) {
      return s * (t /= a) * t * t * t * t + e;
    }
  }, {
    key: "easeOutQuint",
    value: function easeOutQuint(t, e, s, a) {
      return s * ((t = t / a - 1) * t * t * t * t + 1) + e;
    }
  }, {
    key: "easeInOutQuint",
    value: function easeInOutQuint(t, e, s, a) {
      return (t /= a / 2) < 1 ? s / 2 * t * t * t * t * t + e : s / 2 * ((t -= 2) * t * t * t * t + 2) + e;
    }
  }, {
    key: "easeInElastic",
    value: function easeInElastic(t, e, s, a) {
      var i = 1.70158,
        n = 0,
        _r = s;
      return 0 == t ? e : 1 == (t /= a) ? e + s : (n = n || .3 * a, i = _r < Math.abs(s) ? (_r = s, n / 4) : 0 === s && 0 === _r ? n / (2 * Math.PI) * Math.asin(1) : n / (2 * Math.PI) * Math.asin(s / _r), -(_r * Math.pow(2, 10 * --t) * Math.sin((t * a - i) * (2 * Math.PI) / n)) + e);
    }
  }, {
    key: "easeOutElastic",
    value: function easeOutElastic(t, e, s, a) {
      var i = 1.70158,
        n = 0,
        _r2 = s;
      return 0 == t ? e : 1 == (t /= a) ? e + s : (n = n || .3 * a, i = _r2 < Math.abs(s) ? (_r2 = s, n / 4) : 0 === s && 0 === _r2 ? n / (2 * Math.PI) * Math.asin(1) : n / (2 * Math.PI) * Math.asin(s / _r2), _r2 * Math.pow(2, -10 * t) * Math.sin((t * a - i) * (2 * Math.PI) / n) + s + e);
    }
  }, {
    key: "easeInOutElastic",
    value: function easeInOutElastic(t, e, s, a) {
      var i = 1.70158,
        n = 0,
        _r3 = s;
      return 0 == t ? e : 2 == (t /= a / 2) ? e + s : (n = n || a * (.3 * 1.5), i = _r3 < Math.abs(s) ? (_r3 = s, n / 4) : 0 === s && 0 === _r3 ? n / (2 * Math.PI) * Math.asin(1) : n / (2 * Math.PI) * Math.asin(s / _r3), t < 1 ? _r3 * Math.pow(2, 10 * --t) * Math.sin((t * a - i) * (2 * Math.PI) / n) * -.5 + e : _r3 * Math.pow(2, -10 * --t) * Math.sin((t * a - i) * (2 * Math.PI) / n) * .5 + s + e);
    }
  }, {
    key: "easeInBack",
    value: function easeInBack(t, e, s, a) {
      return s * (t /= a) * t * (2.70158 * t - 1.70158) + e;
    }
  }, {
    key: "easeOutBack",
    value: function easeOutBack(t, e, s, a) {
      return s * ((t = t / a - 1) * t * (2.70158 * t + 1.70158) + 1) + e;
    }
  }, {
    key: "easeInOutBack",
    value: function easeInOutBack(t, e, s, a) {
      var i = 1.70158;
      return (t /= a / 2) < 1 ? s / 2 * (t * t * ((1 + (i *= 1.525)) * t - i)) + e : s / 2 * ((t -= 2) * t * ((1 + (i *= 1.525)) * t + i) + 2) + e;
    }
  }, {
    key: "easeInBounce",
    value: function easeInBounce(t, e, s, a) {
      return s - this.easeOutBounce(a - t, 0, s, a) + e;
    }
  }, {
    key: "easeOutBounce",
    value: function easeOutBounce(t, e, s, a) {
      return (t /= a) < 1 / 2.75 ? 7.5625 * s * t * t + e : t < 2 / 2.75 ? s * (7.5625 * (t -= 1.5 / 2.75) * t + .75) + e : t < 2.5 / 2.75 ? s * (7.5625 * (t -= 2.25 / 2.75) * t + .9375) + e : s * (7.5625 * (t -= 2.625 / 2.75) * t + .984375) + e;
    }
  }, {
    key: "easeInOutBounce",
    value: function easeInOutBounce(t, e, s, a) {
      return t < .5 * a ? .5 * this.easeInBounce(2 * t, 0, s, a) + e : .5 * this.easeOutBounce(2 * t - a, 0, s, a) + .5 * s + e;
    }
  }, {
    key: "_clamp",
    value: function _clamp(t) {
      var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      return Math.max(e, Math.min(t, s));
    }
  }, {
    key: "_hexToRgb",
    value: function _hexToRgb(t) {
      return t = (t = 3 === (t = t.replace("#", "")).length ? t.replace(new RegExp("(.)", "g"), "$1$1") : t).match(new RegExp("..", "g")), [r._clamp(parseInt(t[0], 16), 0, 255), r._clamp(parseInt(t[1], 16), 0, 255), r._clamp(parseInt(t[2], 16), 0, 255)];
    }
  }, {
    key: "_rgbToHex",
    value: function _rgbToHex(t) {
      if (Array.isArray(t)) return "#" + t.map(function (t) {
        return Math.abs(Math.round(t)).toString(16).padStart(2, "0");
      }).join("");
    }
  }]);
  return r;
}();


/***/ })
/******/ ]);
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ESound": () => (/* binding */ ESound)
/* harmony export */ });
/* harmony import */ var _tween_min_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }


/**
* Class for managing sounds
* @class ESoundManagerSingleton  
* @license
* ESound does not have a license at this time.
* For licensing contact the author
* @author https://github.com/doubleactii
* Copyright (c) 2023 Evitca Studio

Safari does not support .ogg files, so if you are using safari, do not use .ogg files or this library will not play that sound on safari.
Otherwise, you can use .ogg on any other platform. Cordova included. This supports mp3, wav, ogg, etc.
*/
var ESoundManagerSingleton = /*#__PURE__*/function () {
  /**
   * The max volume to be used
   * 
   * @type {number}
   */

  /**
   * The min volume to be used
   * 
   * @type {number}
   */

  /**
   * The max number of sounds that can be recycled
   * 
   * @type {number}
   */

  /**
   * The max speed this sound can be played at
   * 
   * @type {number}
   */

  /**
   * The frame rate at which to fade the sounds
   * 
   * @type {number}
   */

  /**
   * 
   * @param {number} pVal - Value to clamp
   * @param {number} pMin - Minimum value
   * @param {number} pMax - Maximum value
   * @returns The clamped number
   */

  /**
   * 
   * @param {number} pValue - The number to normalize within a range
   * @param {number} pMin - The min number
   * @param {number} pMax - The max number
   * @param {number} pRange - The range to normalize within
   * @returns The normalized number
   */

  function ESoundManagerSingleton() {
    var _this = this;
    _classCallCheck(this, ESoundManagerSingleton);
    if (!window.AudioContext && !window.webkitAudioContext) {
      console.error('Your device does not support window.AudioContext || window.webkitAudioContext. This library cannot be used');
      return;
    }
    // For WebKit- and Blink-based browsers
    window.AudioContext = window.AudioContext || window.webkitAudioContext;
    // Attach events to start audio through gestures
    window.addEventListener('mousedown', this.resumeAudioCtx.bind(this));
    window.addEventListener('touchstart', this.resumeAudioCtx.bind(this));
    window.addEventListener('load', this.resumeAudioCtx.bind(this));
    // When the window is unfocused, all sounds are suspended
    window.addEventListener('blur', function () {
      _this.focused = false;
      if (_this.soundsPlaying.length) _this.pauseAllSounds(true);
    });
    // When the window is focused all sounds are resumed, and queued sounds are played
    window.addEventListener('focus', function () {
      _this.focused = true;
      if (_this.suspendedSounds.length) _this.resumeAllSounds(true);
      if (_this.queuedSoundsToPlay.length || _this.queuedSoundsToFade.length) _this.playQueuedSounds();
    });

    // The audio context all audio will dervie from
    this.audioCtx = new AudioContext();
    // For older browser support that has this old API.
    if (!this.audioCtx.createGain) this.audioCtx.createGain = this.audioCtx.createGainNode;
    // Declare gain node
    this.gainNode = this.audioCtx.createGain();
    // Assign volume to gainNode
    this.gainNode.gain.value = ESoundManagerSingleton.normalize(ESoundManagerSingleton.MAX_VOLUME);
    // Connect gain node to speakers
    this.gainNode.connect(this.audioCtx.destination);
    // Array of sounds that are currently playing
    this.soundsPlaying = [];
    // Array of sounds that are currently suspended
    this.suspendedSounds = [];
    // Array of sounds that can be resused
    this.recycledSounds = [];
    // Array of sounds that are queued for playing
    this.queuedSoundsToPlay = [];
    // Array of sounds that are queued for fading
    this.queuedSoundsToFade = [];
    // An object that stores the buffer data of a sound so it does not have to be loaded each time
    this.loadedBuffers = {};
    // An object that stores fade information
    this.fader = {};
    // The master volume 
    this.volume = 100;
    // Whether the sound is muted
    this.muted = false;
    // Current state of the library
    this.state = null;
    // Whether or ESound has the window's focus. (Sound are suspended when the focus is lost, and resumed when its gained)
    this.focused = true;
  }

  /**
   * Function to check whether this library can play a sound at a given moment.
   * 
   * @returns {boolean} Whether a sound can be played or not.
   */
  _createClass(ESoundManagerSingleton, [{
    key: "canPlaySound",
    value: function canPlaySound() {
      // API for the developer to define when a sound can and cannot be played. Any sound that tries to play while this returns false will not play
      if (typeof VYLO.Client.canPlaySound === 'function') {
        // If their defined conditions return false, then the sound cannot be played
        if (!VYLO.Client.canPlaySound()) return false;
      }
      return true;
    }
    /**
     * Function to adjust master volume
     * 
     * @param {number} pVolume - The number to change the volume to
     */
  }, {
    key: "adjustVolume",
    value: function adjustVolume(pVolume) {
      // maybe show a GUI of the volume changing
      this.volume = ESoundManagerSingleton.clamp(pVolume, ESoundManagerSingleton.MIN_VOLUME, ESoundManagerSingleton.MAX_VOLUME);
      this.gainNode.gain.value = ESoundManagerSingleton.normalize(this.volume);
    }
    /**
     * Fades this sound to the specified volume in the specified duration via the specified ease
     * 
     * @param {number} [pVolume=100] - The volume to fade to
     * @param {number} [pDuration=5000] - The duration of the fade in ms
     * @param {function} [pEase='easeOutCubic'] - Easing function
     * @param {function} pCallback - Callback to be called when the fade is over
     */
  }, {
    key: "fade",
    value: function fade() {
      var pVolume = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
      var pDuration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5000;
      var pEase = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'easeOutCubic';
      var pCallback = arguments.length > 3 ? arguments[3] : undefined;
      if (isNaN(pVolume)) return;
      if (isNaN(pDuration)) return;
      if (this.state === 'fading') return;
      pVolume = ESoundManagerSingleton.clamp(pVolume, ESoundManagerSingleton.MIN_VOLUME, ESoundManagerSingleton.MAX_VOLUME);
      if (!_tween_min_js__WEBPACK_IMPORTED_MODULE_0__.Tween[pEase]) {
        console.error('Invalid pEase value. Reverted to default.');
      }
      this.state = 'fading';
      this.fader.duration = Math.max(pDuration, 0);
      this.fader.currentIteration = 0;
      this.fader.initialValue = this.volume;
      this.fader.changeInValue = pVolume - this.fader.initialValue;
      this.fader.totalIterations = ESoundManagerSingleton.FRAME_RATE * this.fader.duration;
      this.fader.startStamp = null;
      this.fader.previousTimeStamp = null;
      // This is due to the fact the fader interval is still active, and incrementing the timestamp if the game is not focused
      // When the game is focused, we need to get the value of time that the player was away from the screen and remove it from the current timestamp.
      // The first index holds the alotted time, the second index is used to count the time, when the screen is focused, all the time from the second index gets dumped to the first, and it repeats if neccasary.
      this.fader.durationOffScreen = [0, 0];
      var self = this;
      var fadeInterval = function fadeInterval(pTimeStamp) {
        if (!self.focused) {
          self.fader.raf = requestAnimationFrame(fadeInterval);
          self.fader.durationOffScreen[1] = pTimeStamp - self.fader.previousTimeStamp;
          return;
        }
        if (self.fader.startStamp === null) self.fader.startStamp = pTimeStamp;
        self.adjustVolume(_tween_min_js__WEBPACK_IMPORTED_MODULE_0__.Tween[pEase](self.fader.currentIteration, self.fader.initialValue, self.fader.changeInValue, self.fader.totalIterations));
        if (self.fader.durationOffScreen[1]) {
          self.fader.durationOffScreen[0] += self.fader.durationOffScreen[1];
          self.fader.durationOffScreen[1] = 0;
        }
        var elapsed = pTimeStamp - self.fader.durationOffScreen[0] - self.fader.startStamp;
        if (self.fader.currentIteration < self.fader.totalIterations) self.fader.currentIteration++;
        if (elapsed < self.fader.duration) {
          self.fader.previousTimeStamp = pTimeStamp;
        } else {
          cancelAnimationFrame(self.fader.raf);
          self.fader.duration = self.fader.currentIteration = self.fader.initialValue = self.fader.changeInValue = self.fader.totalIterations = self.fader.startStamp = self.fader.previousTimeStamp = self.fader.durationOffScreen = self.fader.raf = null;
          self.state = null;
          self.adjustVolume(pVolume);
          if (typeof pCallback === 'function') pCallback();
          return;
        }
        self.fader.raf = requestAnimationFrame(fadeInterval);
      };
      this.fader.raf = requestAnimationFrame(fadeInterval);
    }
    /**
     * Master mute
     */
  }, {
    key: "toggleMute",
    value: function toggleMute() {
      this.muted = this.muted ? false : true;
      if (this.muted) {
        this._previousGainNodeValue = this.gainNode.gain.value;
        this.gainNode.gain.value = 0;
      } else {
        this.gainNode.gain.value = this._previousGainNodeValue ? this._previousGainNodeValue : 1;
      }
    }
    /**
     * Checks if the sound manager is currently muted
     * 
     * @returns {boolean} Whether the sound manager is muted
     */
  }, {
    key: "isMuted",
    value: function isMuted() {
      return this.muted;
    }
    /**
     * Plays a sound that is not stored. Plays the sound only. You can only kill this sound, no repeat, no changing volume, etc
     * 
     * @param {string} pSoundPath - The path to the file
     * @param {number} [pVolume=100] - The volume to play the sound
     * @param {number} [pStartTime=0] - The start time of this sound (to play a clipped version)
     * @param {number} [pEndTime=duration] - The end time of this sound (to play a clipped version)
     * @param {number} [pPlaybackRate=1] - The rate at which the sound is played, Higher numbers for faster playback (MAX 10)
     * @returns {SoundSource } The source to this emitted sound. Call source.kill() to stop this sound while its playing. This is the only API this sound has
     */
  }, {
    key: "emit",
    value: function emit(pSoundPath) {
      var pVolume = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
      var pStartTime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var pEndTime = arguments.length > 3 ? arguments[3] : undefined;
      var pPlaybackRate = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
      if (!this.canPlaySound()) return;
      // a very cheap sound that can be used if certain conditions are met. 
      // This sound cannot be referenced and cannot be stopped or configured after creation.
      // If the buffer is loaded, this sound is eligable to play in the background
      // This sound is not going to be saved, this sound is not going to be lopped,
      // and this sound will not use any callbacks. This sound will be very lightweight and will not exist in memory
      var self = this;
      var source = self.audioCtx.createBufferSource();
      // Create a function to kill this sound
      source.kill = function () {
        if (!this.buffer) {
          this.queuedToStop = true;
        } else {
          this.stop();
        }
      };
      var emitSound = function emitSound() {
        var gainNode = self.audioCtx.createGain();
        gainNode.gain.value = ESoundManagerSingleton.normalize(ESoundManagerSingleton.clamp(pVolume, ESoundManagerSingleton.MIN_VOLUME, ESoundManagerSingleton.MAX_VOLUME));
        gainNode.connect(self.gainNode);
        source.connect(gainNode);
        source.buffer = self.loadedBuffers[pSoundPath];
        source.playbackRate.value = pPlaybackRate;
        if (!source.start) source.start = source.noteOn;
        source.start(0, pStartTime, pEndTime ? pEndTime : source.buffer.duration);
      };
      // Check if the loaded buffers already contain the loaded sound data for this sound
      if (this.loadedBuffers[pSoundPath]) {
        emitSound();
        // Otherwise load it
      } else {
        var request = new XMLHttpRequest();
        request.open('GET', pSoundPath);
        request.responseType = 'arraybuffer';
        request.onload = function () {
          var audioData = request.response;
          var success = function success(pDecodedData) {
            self.loadedBuffers[pSoundPath] = pDecodedData;
            // if the user wants to stop the sound before it loads, don't play it
            if (source.queuedToStop) return;
            emitSound();
          };
          var error = function error(pError) {
            console.error("Error with decoding audio data \"".concat(pSoundPath, "\""));
          };
          self.audioCtx.decodeAudioData(audioData, success, error);
        };
        request.send();
      }
      return source;
    }
    /**
     * 
     * @param {number} pSoundPath - The path of the sound file
     * @param {number} [pVolume=100] - The volume of the sound
     * @param {number} [pStartTime=0] - The start time of this sound (to play a clipped version)
     * @param {number} [pEndTime=duration] - The end time of this sound (to play a clipped version)
     * @param {boolean} [pSave=false] - Whether to save this sound, or kill/recycle it when it's completed
     * @param {boolean} [pPlayUnfocused=false] - If this sound is set to playUnfocused then it will not be suspended automatically when the game screen is not focused
     * @param {number} [pPlaybackRate=1] - The rate at which the sound is played, Higher numbers for faster playback (MAX 10)
     * @param {boolean} [pLoop=false] - Whether this sound should loop or not
     * @param {Object} pCallbackObject - Object full of callbacks to call (soon to be deprecated and replaced with on('event') handlers)
     * @param {function} pCallbackObject.onStarted - Callback for when the sound has started playing
     * @param {function} pCallbackObject.onStopped - Callback for when the sound has stopped playing
     * @param {function} pCallbackObject.onEnded - Callback for when the sound has ended
     * @param {function} pCallbackObject.onSuspended - Callback for when the sound has been paused
     * @param {function} pCallbackObject.onResumed - Callback for when the sound has been resumed
     * @returns { Sound } - A sound object that has vast API on controlling it
     */
  }, {
    key: "createSound",
    value: function createSound(pSoundPath, pVolume, pStartTime, pEndTime, pSave, pPlayUnfocused, pPlaybackRate, pLoop, pCallbackObject) {
      // If there is a reusable sound, use that sound rather than create a new one
      if (this.recycledSounds.length) {
        var sound = this.recycledSounds.pop();
        sound.build(pSoundPath, pVolume, pStartTime, pEndTime, pSave, pPlayUnfocused, pPlaybackRate, pLoop, pCallbackObject);
        return sound;
      }
      return new Sound(pSoundPath, pVolume, pStartTime, pEndTime, pSave, pPlayUnfocused, pPlaybackRate, pLoop, pCallbackObject);
    }
    /**
     * This effectively stops all sounds in the game except those specified in the pException array
     * 
     * @param {Array} pException - an array of sounds that should not stop
     */
  }, {
    key: "stopAllSounds",
    value: function stopAllSounds(pException) {
      for (var i = this.soundsPlaying.length - 1; i >= 0; i--) {
        var sound = this.soundsPlaying[i];
        // If the sound is not set to be saved it will be killed
        if (Array.isArray(pException) && pException.includes(sound)) {
          continue;
        }
        sound.stop();
      }
    }
    /**
     * This effectively kills all sounds in the game and subjects them to be recycled 
     */
  }, {
    key: "killAllSounds",
    value: function killAllSounds() {
      // this effectively kills all sounds in the game, and subjects them to be recycled
      for (var i = this.soundsPlaying.length - 1; i >= 0; i--) {
        var sound = this.soundsPlaying[i];
        sound.kill();
      }
    }
    /**
     * Pauses all sounds in the game
     * 
     * @param {boolean} pFocus - If this function was called automatically by the game being unfocused
     */
  }, {
    key: "pauseAllSounds",
    value: function pauseAllSounds(pFocus) {
      for (var i = this.soundsPlaying.length - 1; i >= 0; i--) {
        var sound = this.soundsPlaying[i];
        // if this sound is set to playUnfocused then it will not be suspended automatically when the game screen is not focused
        if (pFocus && sound.getFocusStatus()) continue;
        sound.pause();
      }
    }
    /**
     * Resumes all sounds in games
     * 
     * @param {boolean} pFocus - If this function was called automatically by the game being focused
     */
  }, {
    key: "resumeAllSounds",
    value: function resumeAllSounds(pFocus) {
      for (var i = this.suspendedSounds.length - 1; i >= 0; i--) {
        var sound = this.suspendedSounds[i];
        sound.resume();
      }
    }
    /**
     * @private
     * Finds all queued sounds (sounds that were played when the game was minimized or out of focus and plays them)
     */
  }, {
    key: "playQueuedSounds",
    value: function playQueuedSounds() {
      for (var i = this.queuedSoundsToPlay.length - 1; i >= 0; i--) {
        var sound = this.queuedSoundsToPlay[i];
        this.queuedSoundsToPlay.splice(i, 1);
        sound.play();
      }
      for (var _i = this.queuedSoundsToFade.length - 1; _i >= 0; _i--) {
        var _sound = this.queuedSoundsToFade[_i];
        this.queuedSoundsToFade.splice(_i, 1);
        _sound.queuedFade();
      }
    }
    /**
     * Removes the loaded audio buffer data for this sound
     * 
     * @param {string} pSoundPath - The path of the sound file
     */
  }, {
    key: "unloadSound",
    value: function unloadSound(pSoundPath) {
      if (this.loadedBuffers[pSoundPath]) delete this.loadedBuffers[pSoundPath];
    }
    /**
     * Recycles the sound for reuse later instead of deleting it. All binding info on the sound is removed
     * 
     * @private
     * @param {Sound} pSound - The sound to recycle 
     * @returns 
     */
  }, {
    key: "recycleSound",
    value: function recycleSound(pSound) {
      if (!(pSound instanceof Sound)) return;
      pSound.kill();
    }
    /**
     * This will start playing sounds that were initially blocked by not having a user gesture.
     * This will also restart sounds when a mobile device backs out of an app, and then rejoins the app
     */
  }, {
    key: "resumeAudioCtx",
    value: function resumeAudioCtx() {
      if (this.audioCtx.state !== 'running') {
        this.audioCtx.resume().then(function () {
          // console.log('ESound: autostart attempt of audio context worked.');
        }, function () {
          // console.warn('ESound: autostart attempt of audio context failed.');
        });
      }
      this.ready = true;
    }
  }]);
  return ESoundManagerSingleton;
}();
_defineProperty(ESoundManagerSingleton, "MAX_VOLUME", 200);
_defineProperty(ESoundManagerSingleton, "MIN_VOLUME", -200);
_defineProperty(ESoundManagerSingleton, "MAX_RECYCLED_SOUNDS", 500);
_defineProperty(ESoundManagerSingleton, "MAX_PLAYBACK_RATE", 10);
_defineProperty(ESoundManagerSingleton, "FRAME_RATE", 60);
_defineProperty(ESoundManagerSingleton, "clamp", function (pVal, pMin, pMax) {
  return Math.max(pMin, Math.min(pVal, pMax));
});
_defineProperty(ESoundManagerSingleton, "normalize", function (pValue) {
  var pMin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var pMax = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;
  var pRange = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  return (pValue - pMin) / (pMax - pMin) * pRange;
});
;
var ESound = new ESoundManagerSingleton();

/**
 * A small class to represent a sound. Has useful API to handle the sound
 * 
 * @class Sound
 */
var Sound = /*#__PURE__*/function () {
  /*	commented out because older devices *cough* iOS devices that are under 14.5 do not support this and prevent the game from loading
  	#soundPath;
  	#startTime;
  	#endTime;
  	#save;
  	#duration;
  	#source;
  	#gainNode;
  	#loaded = false;
  	#playAfterLoad = false;
  	#muted = false;
  	#state;
  	#startedTimeStamp;
  	#suspendedTimeStamp = 0;
  	#playUnfocused;
  	#fader = {};
  	#stopSignal = false;
  	#_loop = false;
  	#_playbackRate = 1;
  	#_volume = 100;
  	#_info = { 'soundPath': null, 'duration': null };
  */
  /**
   * 
   * @param {number} pSoundPath - The path of the sound file
   * @param {number} pVolume - The volume of the sound
   * @param {number} pStartTime - The start time of this sound (to play a clipped version)
   * @param {number} pEndTime - The end time of this sound (to play a clipped version)
   * @param {boolean} pSave - Whether to save this sound, or delete it when it's completed
   * @param {boolean} pPlayUnfocused - If this sound is set to playUnfocused then it will not be suspended automatically when the game screen is not focused
   * @param {number} pPlaybackRate - The rate at which the sound is played, Higher numbers for faster playback (MAX 10)
   * @param {boolean} pLoop - Whether this sound should loop or not
   * @param {Object} pCallbackObject - Object full of callbacks to call (soon to be deprecated and replaced with on('event') handlers)
   * @param {function} pCallbackObject.onStarted - Callback for when the sound has started playing
   * @param {function} pCallbackObject.onStopped - Callback for when the sound has stopped playing
   * @param {function} pCallbackObject.onEnded - Callback for when the sound has ended
   * @param {function} pCallbackObject.onSuspended - Callback for when the sound has been paused
   * @param {function} pCallbackObject.onResumed - Callback for when the sound has been resumed
   * @returns { Sound } - A sound object that has vast API on controlling it
   */
  function Sound(pSoundPath, pVolume, pStartTime, pEndTime, pSave, pPlayUnfocused, pPlaybackRate, pLoop, pCallbackObject) {
    _classCallCheck(this, Sound);
    this.soundPath = null;
    this.startTime = null;
    this.endTime = null;
    this.save = null;
    this.duration = null;
    this.source = null;
    this.gainNode = null;
    this.loaded = false;
    this.playAfterLoad = false;
    this.muted = false;
    this.state = null;
    this.startedTimeStamp = null;
    this.suspendedTimeStamp = 0;
    this.playUnfocused = null;
    this.fader = {};
    this.stopSignal = false;
    this._loop = false;
    this._playbackRate = 1;
    this._volume = 100;
    this._info = {
      'soundPath': null,
      'duration': null
    };
    this.build(pSoundPath, pVolume, pStartTime, pEndTime, pSave, pPlayUnfocused, pPlaybackRate, pLoop, pCallbackObject);
  }
  /**
   * Gets the current volume of this sound
   * 
   * @returns {number} The current volume of this sound
   */
  _createClass(Sound, [{
    key: "volume",
    get: function get() {
      return this._volume;
    }
    /**
     * Sets the volume of this sound
     * 
     * @param {number} pNewVolume - The volume to set
     */,
    set: function set(pNewVolume) {
      this._volume = ESoundManagerSingleton.clamp(pNewVolume, ESoundManagerSingleton.MIN_VOLUME, ESoundManagerSingleton.MAX_VOLUME);
      if (this.loaded) this.gainNode.gain.value = ESoundManagerSingleton.normalize(this._volume);
    }
    /**
     * Toggleable mute feature for this sound. Flips between muted and unmuted
     * 
     * @returns {Sound} This sound instance
     */
  }, {
    key: "toggleMute",
    value: function toggleMute() {
      if (!this.loaded || !this.source) return;
      this.muted = this.muted ? false : true;
      if (this.muted) {
        this.gainNode.gain.value = 0;
      } else {
        this.gainNode.gain.value = ESoundManagerSingleton.normalize(this._volume);
      }
      return this;
    }
    /**
     * Get the loop status of this sound
     * 
     * @returns {boolean} Whether this sound is set to loop or not
     */
  }, {
    key: "loop",
    get: function get() {
      return this._loop;
    }
    /**
     * Set the loop status of this sound
     * 
     * @param {boolean} pLoopValue - The value which to set the loop status to. Truthy values resolve to true, and falsely values resovle to false
     */,
    set: function set(pLoopValue) {
      this._loop = pLoopValue ? true : false;
      if (this.source) this.source.loop = this._loop;
    }
    /**
     * Toggleable loop feature for this sound. Flips between loop and unlooped
     * 
     * @returns {Sound} This sound instance
     */
  }, {
    key: "toggleLoop",
    value: function toggleLoop() {
      this._loop = this._loop ? false : true;
      if (this.source) this.source.loop = this._loop;
      return this;
    }
    /**
     * Get the playback status of this sound
     * 
     * @returns {number} The playback rate of this sound
     */
  }, {
    key: "playbackRate",
    get: function get() {
      return this._playbackRate;
    }
    /**
     * Set the playback status of this sound
     * 
     * @param {number} pNewPlaybackRate - The value which to set the playback status to. Clamped to 10
     */,
    set: function set(pNewPlaybackRate) {
      this._playbackRate = ESoundManagerSingleton.clamp(pNewPlaybackRate, 1, ESoundManagerSingleton.MAX_PLAYBACK_RATE);
      if (this.source) this.source.playbackRate.value = this._playbackRate;
    }
    /**
     * Set the info of this sound
     * The new value is not used, as this is a "read-only" variable. So any attempts to set it will not work
     * 
     * @param {*} pNewInfo - The new value
     */
  }, {
    key: "info",
    get:
    /**
     * Get the info object of this sound
     * 
     * @returns {Objecct} The info object of this sound
     */
    function get() {
      if (this.loaded) {
        if (this.source) {
          this._info.duration = this.duration;
        }
        this._info.soundPath = this.soundPath;
      } else {
        this._info.soundPath = this.soundPath;
      }
      return _objectSpread({}, this._info);
    }
    /**
     * 
     * @param {number} pSoundPath - The path of the sound file
     * @param {number} pVolume - The volume of the sound
     * @param {number} pStartTime - The start time of this sound (to play a clipped version)
     * @param {number} pEndTime - The end time of this sound (to play a clipped version)
     * @param {boolean} pSave - Whether to save this sound, or delete it when it's completed
     * @param {boolean} pPlayUnfocused - If this sound is set to true then it will not be suspended automatically when the game screen is not focused
     * @param {number} pPlaybackRate - The rate at which the sound is played, Higher numbers for faster playback (MAX 10)
     * @param {boolean} pLoop - Whether this sound should loop or not
     * @param {Object} pCallbackObject - Object full of callbacks to call (soon to be deprecated and replaced with on('event') handlers)
     * @param {function} pCallbackObject.onStarted - Callback for when the sound has started playing
     * @param {function} pCallbackObject.onStopped - Callback for when the sound has stopped playing
     * @param {function} pCallbackObject.onEnded - Callback for when the sound has ended
     * @param {function} pCallbackObject.onSuspended - Callback for when the sound has been paused
     * @param {function} pCallbackObject.onResumed - Callback for when the sound has been resumed
     * @returns { Sound } - A sound object that has vast API on controlling it
     */,
    set: function set(pNewInfo) {
      // makes this variable read only basically
      this._info = this._info;
    }
  }, {
    key: "build",
    value: function build(pSoundPath) {
      var pVolume = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
      var pStartTime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var pEndTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var pSave = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      var pPlayUnfocused = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
      var pPlaybackRate = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1;
      var pLoop = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
      var pCallbackObject = arguments.length > 8 ? arguments[8] : undefined;
      this.soundPath = pSoundPath;
      this.startTime = Math.max(pStartTime, 0);
      this.endTime = Math.max(pEndTime, 0);
      this.save = pLoop ? true : pSave;
      this._playbackRate = ESoundManagerSingleton.clamp(pPlaybackRate, 1, ESoundManagerSingleton.MAX_PLAYBACK_RATE);
      this.playUnfocused = pPlayUnfocused ? true : false;
      this.state = null;
      this._loop = pLoop ? true : false;
      this._volume = ESoundManagerSingleton.clamp(pVolume, ESoundManagerSingleton.MIN_VOLUME, ESoundManagerSingleton.MAX_VOLUME);
      if (pCallbackObject && pCallbackObject.constructor === Object) {
        if (typeof pCallbackObject.onStarted === 'function') this.onStarted = pCallbackObject.onStarted.bind(this);
        if (typeof pCallbackObject.onStopped === 'function') this.onStopped = pCallbackObject.onStopped.bind(this);
        if (typeof pCallbackObject.onEnded === 'function') this.onEnded = pCallbackObject.onEnded.bind(this);
        if (typeof pCallbackObject.onSuspended === 'function') this.onSuspended = pCallbackObject.onSuspended.bind(this);
        if (typeof pCallbackObject.onResumed === 'function') this.onResumed = pCallbackObject.onResumed.bind(this);
      } else if (pCallbackObject && pCallbackObject.constructor !== Object) {
        console.warn('ESound Library: Invalid variable type passed for pCallbackObject.');
      }
      // If this sound will use a buffer that is already stored, do not load it, there is no need, when going to play
      // this sound, it will just use the buffer data of the previous sound that had it.
      if (!ESound.loadedBuffers[this.soundPath]) {
        this.load();
      } else {
        this.loaded = true;
      }
    }
    /**
     * Loads this sound and stores its data so future sounds can use the same buffer
     */
  }, {
    key: "load",
    value: function load() {
      var request = new XMLHttpRequest();
      var self = this;
      request.open('GET', self.soundPath);
      request.responseType = 'arraybuffer';
      request.onload = function () {
        var audioData = request.response;
        var success = function success(pDecodedData) {
          self.loaded = true;
          ESound.loadedBuffers[self.soundPath] = pDecodedData;
          // The developer attempted to play the sound while it was still loading,
          // This has been set so that the sound will play once it's finished loading now
          if (self.playAfterLoad) {
            // A signal to stop this sound was sent, but the sound wasn't loaded to play at that time, don't allow a sound that is signaled to stop to play
            if (self.stopSignal) {
              self.stopSignal = false;
              return;
            } else {
              self.play();
            }
          }
        };
        var error = function error(pError) {
          self.loaded = false;
          console.error("Error with decoding audio data \"".concat(self.soundPath, "\" This sound has been killed."));
          self.kill();
        };
        ESound.audioCtx.decodeAudioData(audioData, success, error);
      };
      request.send();
    }
    /**
     * Pauses this sound
     * 
     * @returns {Sound} This sound instance
     */
  }, {
    key: "pause",
    value: function pause() {
      if (!this.loaded) return;
      this.stop('suspended');
      this.state = 'suspended';
      this.suspendedTimeStamp = ESound.audioCtx.currentTime - this.startedTimeStamp;
      // This sound is no longer considered to be playing, so remove it from the array
      if (ESound.soundsPlaying.includes(this)) ESound.soundsPlaying.splice(ESound.soundsPlaying.indexOf(this), 1);
      // If this sound is not apart of the suspended sounds array add it
      if (!ESound.suspendedSounds.includes(this)) ESound.suspendedSounds.push(this);
      if (typeof this.onSuspended === 'function') this.onSuspended();
      return this;
    }
    /**
     * Resumes playing this sound
     * 
     * @returns {Sound} This sound instance
     */
  }, {
    key: "resume",
    value: function resume() {
      if (!this.loaded) return;
      // This sound is no longer considered to be suspended, so remove it from the array
      if (ESound.suspendedSounds.includes(this)) ESound.suspendedSounds.splice(ESound.suspendedSounds.indexOf(this), 1);
      // This sound is no longer suspended and is now playing again, add it to the playing array
      if (!ESound.soundsPlaying.includes(this)) ESound.soundsPlaying.push(this);
      // this will use the this.suspendedTimeStamp value to resume
      this.play(true);
      this.state = this.fader.raf ? 'fading' : 'playing';
      if (typeof this.onResumed === 'function') this.onResumed();
      return this;
    }
    /**
     * Stops this sound from playing
     * 
     * @param {string} pState - The current state of this sound. It's used to figure out if a callback should be dispatched
     * @returns {Sound} This sound instance
     */
  }, {
    key: "stop",
    value: function stop(pState) {
      // The sound isn't loaded yet, but the developer wants to stop this sound, so we send out a stopSignal, so that when the sound is loaded and attempted to play, it will not play.
      if (!this.source) {
        this.stopSignal = true;
        return;
      }
      var wasPlaying = this.state === 'playing' || this.state === 'fading' || this.state === 'suspended' ? true : false;
      // This sound is no longer considered to be playing, so remove it from the array
      if (ESound.soundsPlaying.includes(this)) ESound.soundsPlaying.splice(ESound.soundsPlaying.indexOf(this), 1);
      if (this.source) {
        if (!this.source.stop) this.source.stop = this.source.noteOff;
        this.source.stop();
        this.source.disconnect();
        this.gainNode.disconnect();
        this.source = null;
        this.gainNode = null;
      }
      this.state = pState ? pState : 'stopped';
      if (this.state === 'stopped' && wasPlaying && typeof this.onStopped === 'function') this.onStopped();
      return this;
    }
    /**
     * Plays this sound
     * 
     * @param {boolean} pResume - If this is being played from a paused state
     * @returns {Sound} This sound instance
     */
  }, {
    key: "play",
    value: function play(pResume) {
      // A sound cannot be played if it's sound name is not referencable, 
      // a sound that is recycled has no sound information to be played
      // and if the game's API doesn't allow a sound to be played at it's current time, then it can't play.
      if (!this.soundPath || this.state === 'recycled' || !ESound.canPlaySound()) return;
      // If this sound is not loaded, it cannot be played, however there is a chance that a sound with the same buffer
      // information has been played before and stored. In this case it does not need to wait to load, it instead checks to see
      // if that buffer information is avaiable, and if it is, it allows the sound to be played with that data.
      if (!this.loaded && !ESound.loadedBuffers[this.soundPath]) {
        this.playAfterLoad = true;
        return;
      }
      // The game does not have focus at the moment, this sound will be automatically queued and played when the screen gets focus again if it is not already preset to play even when focus is lost
      if (!ESound.focused && !this.playUnfocused) {
        if (!ESound.queuedSoundsToPlay.includes(this)) ESound.queuedSoundsToPlay.push(this);
        return;
      }
      // if you already have a soure and a gainNode, disconnect them and let them be garbage collected
      if (this.source) {
        this.source.disconnect();
        this.gainNode.disconnect();
        this.source = null;
        this.gainNode = null;
      }
      if (ESound.suspendedSounds.includes(this)) ESound.suspendedSounds.splice(ESound.suspendedSounds.indexOf(this), 1);
      var source = ESound.audioCtx.createBufferSource();
      var gainNode = ESound.audioCtx.createGain();
      var self = this;
      gainNode.gain.value = ESoundManagerSingleton.normalize(this._volume);
      gainNode.connect(ESound.gainNode);
      source.connect(gainNode);
      // ESound.gainNode.connect(ESound.audioCtx.destination);
      source.buffer = ESound.loadedBuffers[this.soundPath];
      source.playbackRate.value = this._playbackRate;
      // sound.stop() calls this as well
      source.onended = function () {
        // if this sound was stopped, and it is a sound that will be saved return early
        if (self.state === 'stopped' && self.save) {
          return;
        } else if (self.state === 'restart') {
          // since the sound is restarting we don't want it to fire off the `onEnded` event.
          self.play();
          return;
        } else if (self.state === 'suspended') {
          return;
        }
        if (self.state !== 'stopped' && typeof self.onEnded === 'function') self.onEnded();
        if (self._loop) {
          self.play();
          return;
        }
        /*
        	If this is a one use sound, it will be recycled or killed.
        	A developer may still hold a reference to this sound but will not be able to do anything to it.
        	If you are using a one use sound, it is best to play a sound on its creation without storing it.
        	ESound.createSound('soundPath', volume, startTime, endTime, playrate, loop).play()
        */
        if (!self.save) self.kill();
      };
      this.source = source;
      this.gainNode = gainNode;
      this.duration = source.buffer.duration;
      this.playAfterLoad = null;
      if (!source.start) source.start = source.noteOn;
      source.start(0, this.suspendedTimeStamp ? this.suspendedTimeStamp * this._playbackRate : this.startTime, this.endTime ? this.endTime : this.duration);
      /* 				
      		// This works, however it is commented out because manually looping is alot easier to do, and easier to stuff callbacks into it when done manually.
      		source.loop = this._loop;
      		source.loopStart = this.startTime;
      		source.loopEnd = this.endTime ? this.endTime : source.buffer.duration; 
      */
      this.state = 'playing';
      this.startedTimeStamp = ESound.audioCtx.currentTime - (this.suspendedTimeStamp ? this.suspendedTimeStamp : this.startTime);
      this.suspendedTimeStamp = 0;
      if (!ESound.soundsPlaying.includes(this)) ESound.soundsPlaying.push(this);
      if (!pResume && typeof this.onStarted === 'function') this.onStarted();
      return this;
    }
    /**
     * Restarts this sound
     * 
     * @returns {Sound} This sound instance
     */
  }, {
    key: "restart",
    value: function restart() {
      this.stop('restart');
      return this;
    }
    /**
     * Get whether this sound will play when the window is unfocused
     * @returns {boolean} Whether or not this sound will play when the window is unfocused
     */
  }, {
    key: "getFocusStatus",
    value: function getFocusStatus() {
      return this.playUnfocused ? true : false;
    }
    /**
     * Kills this sound. Wipes it, and recycles it if the recycle manager isn't full.
     * If the recycle manager is full, this sound will become an empty class instance.
     */
  }, {
    key: "kill",
    value: function kill() {
      this.wipe();
      if (ESound.recycledSounds.length < ESoundManagerSingleton.MAX_RECYCLED_SOUNDS) {
        ESound.recycledSounds.push(this);
      } else {
        // remove all properties from this sound object, since it no longer will be used.
        // any references to this should be removed so that it can be garbage collected
        for (var variable in this) delete this[variable];
      }
    }
    /**
     * Resets this sound to default state
     */
  }, {
    key: "wipe",
    value: function wipe() {
      this.onStarted = null;
      this.onStopped = null;
      this.onEnded = null;
      this.onSuspended = null;
      this.onResumed = null;
      this.stop('wipe');
      cancelAnimationFrame(this.fader.raf);
      if (this.source) {
        this.source.disconnect();
        this.gainNode.disconnect();
      }
      this.soundPath = null;
      this.startTime = null;
      this.endTime = null;
      this.save = null;
      this.duration = null;
      this._playbackRate = 1;
      this.source = null;
      this.gainNode = null;
      this.loaded = false;
      this.playAfterLoad = null;
      this.state = 'recycled';
      this.startedTimeStamp = null;
      this.suspendedTimeStamp = 0;
      this.playUnfocused = null;
      this.fader.duration = this.fader.currentIteration = this.fader.initialValue = this.fader.changeInValue = this.fader.totalIterations = this.fader.startStamp = this.fader.previousTimeStamp = this.fader.durationOffScreen = this.fader.queue = this.fader.raf = null;
      this.stopSignal = false;
      this._loop = false;
      this._volume = 100;
      this._info.soundPath = this._info.duration = null;
      if (ESound.soundsPlaying.includes(this)) ESound.soundsPlaying.splice(ESound.soundsPlaying.indexOf(this), 1);
      if (ESound.suspendedSounds.includes(this)) ESound.suspendedSounds.splice(ESound.suspendedSounds.indexOf(this), 1);
      if (ESound.queuedSoundsToPlay.includes(this)) ESound.queuedSoundsToPlay.splice(ESound.queuedSoundsToPlay.indexOf(this), 1);
      if (ESound.queuedSoundsToFade.includes(this)) ESound.queuedSoundsToFade.splice(ESound.queuedSoundsToFade.indexOf(this), 1);
    }
    /**
     * Get the current timestamp of the sound playing
     * 
     * @returns {number} The current timestamp into the sound
     */
  }, {
    key: "getCurrentTime",
    value: function getCurrentTime() {
      if (this.suspendedTimeStamp) {
        return this.suspendedTimeStamp * this._playbackRate;
      } else if (this.startedTimeStamp) {
        return ESound.audioCtx.currentTime - this.startedTimeStamp;
      } else {
        return 0;
      }
    }
    /**
     * Fades this sound to the specified volume in the specified duration via the specified ease
     * 
     * @param {number} [pVolume=100] - The volume to fade to
     * @param {number} [pDuration=5000] - The duration of the fade in ms
     * @param {function} [pEase='easeOutCubic'] - Easing function
     * @param {function} pCallback - Callback to be called when the fade is over
     * @returns {Sound} This sound instance
     */
  }, {
    key: "fade",
    value: function fade() {
      var pVolume = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
      var pDuration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5000;
      var pEase = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'easeOutCubic';
      var pCallback = arguments.length > 3 ? arguments[3] : undefined;
      if (isNaN(pVolume)) return;
      if (isNaN(pDuration)) return;
      // If a sound is not playing, it cannot be faded.
      if (this.state !== 'playing' && ESound.focused) return;
      // The game does not have focus at the moment, this sound will be automatically queued and faded when the screen gets focus again if it is not already preset to play/fade even when the screen has no focus
      if (!ESound.focused && !this.playUnfocused) {
        // If this sound is already queued to fade, then just exit out
        if (ESound.queuedSoundsToFade.includes(this)) return;
        this.fader.queue = {
          'volume': pVolume,
          'duration': pDuration,
          'ease': pEase,
          'callback': pCallback
        };
        ESound.queuedSoundsToFade.push(this);
        return;
      }
      if (!_tween_min_js__WEBPACK_IMPORTED_MODULE_0__.Tween[pEase]) {
        pEase = 'easeOutCubic';
        console.warn('ESound: Invalid pEase value. Reverted to default.');
      }
      // Get rid of the queue information if it exists, it is no longer needed
      if (this.fader.queue) this.fader.queue = null;
      pVolume = ESoundManagerSingleton.clamp(pVolume, ESoundManagerSingleton.MIN_VOLUME, ESoundManagerSingleton.MAX_VOLUME);
      this.fader.duration = Math.max(pDuration, 0);
      this.fader.currentIteration = 0;
      this.fader.initialValue = this._volume;
      this.fader.changeInValue = pVolume - this.fader.initialValue;
      this.fader.totalIterations = ESoundManagerSingleton.FRAME_RATE * this.fader.duration;
      this.fader.startStamp = null;
      this.fader.previousTimeStamp = null;
      // This is due to the fact the fader interval is still active, and incrementing the timestamp if the game is not focused
      // When the game is focused, we need to get the value of time that the player was away from the screen and remove it from the current timestamp.
      // The first index holds the alotted time, the second index is used to count the time, when the screen is focused, all the time from the second index gets dumped to the first, and it repeats if neccasary.
      this.fader.durationOffScreen = [0, 0];
      this.state = 'fading';
      var self = this;
      var fadeInterval = function fadeInterval(pTimeStamp) {
        if (!ESound.focused) {
          self.fader.raf = requestAnimationFrame(fadeInterval);
          self.fader.durationOffScreen[1] = pTimeStamp - self.fader.previousTimeStamp;
          return;
        }
        if (self.fader.startStamp === null) self.fader.startStamp = pTimeStamp;
        self.volume = _tween_min_js__WEBPACK_IMPORTED_MODULE_0__.Tween[pEase](self.fader.currentIteration, self.fader.initialValue, self.fader.changeInValue, self.fader.totalIterations);
        if (self.fader.durationOffScreen[1]) {
          self.fader.durationOffScreen[0] += self.fader.durationOffScreen[1];
          self.fader.durationOffScreen[1] = 0;
        }
        var elapsed = pTimeStamp - self.fader.durationOffScreen[0] - self.fader.startStamp;
        if (self.fader.currentIteration < self.fader.totalIterations) self.fader.currentIteration++;
        if (elapsed < self.fader.duration) {
          self.fader.previousTimeStamp = pTimeStamp;
        } else {
          cancelAnimationFrame(self.fader.raf);
          self.fader.duration = self.fader.currentIteration = self.fader.initialValue = self.fader.changeInValue = self.fader.totalIterations = self.fader.startStamp = self.fader.previousTimeStamp = self.fader.durationOffScreen = self.fader.queue = self.fader.raf = null;
          // When a sound is faded down to `0` or any other value. Just because it may be muted, does not mean it is stopped. 
          // The state of the sound is still considered to be playing after its done fading
          self.state = 'playing';
          self.volume = pVolume;
          if (typeof pCallback === 'function') pCallback();
          return;
        }
        self.fader.raf = requestAnimationFrame(fadeInterval);
      };
      this.fader.raf = requestAnimationFrame(fadeInterval);
      return this;
    }
    /**
     * Start the queued fade
     */
  }, {
    key: "queuedFade",
    value: function queuedFade() {
      if (this.fader.queue) this.fade(this.fader.queue.volume, this.fader.queue.duration, this.fader.queue.ease, this.fader.queue.callback);
    }
  }]);
  return Sound;
}();
})();

var __webpack_exports__ESound = __webpack_exports__.ESound;
export { __webpack_exports__ESound as ESound };
